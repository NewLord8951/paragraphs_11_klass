43
1. **Определения понятий:**
   - **Дерево**: это структура данных, состоящая из узлов, где каждый узел может иметь ноль или более дочерних узлов. Дерево имеет единственный корень, от которого исходят все остальные узлы.
   - **Корень**: это верхний узел дерева, который не имеет родителя.
   - **Лист**: это узел дерева, который не имеет дочерних узлов.
   - **Родитель**: узел, который имеет один или более дочерних узлов.
   - **Сын**: узел, который является дочерним узлом для другого узла (родителя).
   - **Потомок**: любой узел, который находится ниже данного узла в иерархии дерева.
   - **Предок**: любой узел, который находится выше данного узла в иерархии дерева.
   - **Высота дерева**: максимальная длина пути от корня до самого глубокого листа. Высота дерева с одним узлом равна 0.

2. **Где используются структуры типа «дерево» в информатике и в других областях?**
   - **Базы данных**: деревья используются для организации данных (например, B-деревья).
   - **Файловые системы**: структура каталогов и файлов представляется в виде дерева.
   - **Алгоритмы поиска**: деревья используются в алгоритмах, таких как бинарные деревья поиска.
   - **Компьютерная графика**: деревья используются для представления иерархий объектов.
   - **Обработка естественного языка**: деревья используются для синтаксического разбора предложений.

3. **Рекурсивное определение дерева:**
   Дерево может быть определено рекурсивно как:
   - Пустое дерево (без узлов) является деревом.
   - Непустое дерево состоит из корневого узла и поддеревьев, каждое из которых также является деревом.

4. **Можно ли считать, что линейный список — это частный случай дерева?**
   Да, линейный список можно рассматривать как частный случай дерева, где каждый узел имеет только одного потомка (правого сына), а все узлы, кроме последнего, имеют только одного сына.

5. **Свойства дерева поиска:**
   - Для каждого узла все значения в левом поддереве меньше значения узла.
   - Для каждого узла все значения в правом поддереве больше значения узла.
   - Левое и правое поддеревья также являются деревьями поиска.

6. **Как построить дерево поиска из массива данных:**
   Для построения дерева поиска из отсортированного массива можно использовать рекурсивный подход:
   - Выбрать средний элемент массива в качестве корня.
   - Рекурсивно построить левое поддерево из элементов, находящихся слева от среднего элемента.
   - Рекурсивно построить правое поддерево из элементов, находящихся справа от среднего элемента.

7. **Преимущества поиска с помощью дерева:**
   - Быстрый поиск: среднее время поиска в сбалансированном дереве поиска составляет O(log n).
   - Упрощение операций вставки и удаления по сравнению с массивами.
   - Динамическое изменение размера структуры данных.

8. **Что такое обход дерева?**
   Обход дерева — это процесс посещения всех узлов дерева в определённом порядке.

9. **Способы обхода дерева:**
   - **Прямой обход (pre-order)**: корень, левое поддерево, правое поддерево.
   - **Симметричный обход (in-order)**: левое поддерево, корень, правое поддерево.
   - **Обратный обход (post-order)**: левое поддерево, правое поддерево, корень.
   - **Уровневый обход (level-order)**: узлы посещаются по уровням, начиная с корня.
   - Другие способы обхода могут включать обход по диагоналям или обход по спирали.

10. **Как строится дерево для вычисления арифметического выражения?**
    Дерево для вычисления арифметического выражения строится, где каждый узел представляет оператор (например, +, -, *, /), а дочерние узлы представляют операнды (числа или подвыражения). Операторы с более высоким приоритетом располагаются выше в дереве.

11. **Как можно представить дерево в программе на Паскале?**
    В Паскале дерево можно представить с помощью записи (record):
    ```pascal
    type
      PNode = ^TNode;
      TNode = record
        Value: Integer;
        Left, Right: PNode;
      end;
    ```

12. **Как указать, что узел дерева не имеет левого (правого) сына?**
    Для указания, что узел не имеет левого или правого сына, можно установить соответствующий указатель (Left или Right) в `nil`.

13. **Как выделяется память под новый узел?**
    Память под новый узел выделяется с помощью оператора `new` в Паскале:
    ```pascal
    var
      NewNode: PNode;
    begin
      New(NewNode);
      NewNode^.Value := SomeValue;
      NewNode^.Left := nil;
      NewNode^.Right := nil;
    end;
    ```

14. **Почему рекурсивные алгоритмы работы с деревьями получаются проще, чем нерекурсивные?**
    Рекурсивные алгоритмы проще, потому что они естественно соответствуют иерархической структуре дерева. Рекурсия позволяет избежать явного управления стеком и упрощает код, так как каждый вызов функции обрабатывает поддерево, что делает логику более понятной.

15. **Как хранить двоичное дерево в массиве? Можно ли использовать такой приём для хранения деревьев, в которых узлы могут иметь больше двух сыновей?**
    Двоичное дерево можно хранить в массиве, где для узла с индексом `i`:
    - Левый сын находится по индексу `2*i + 1`.
    - Правый сын находится по индексу `2*i + 2`.
    Для деревьев с большим количеством сыновей этот метод не подходит, так как необходимо будет использовать более сложные структуры, например, списки или массивы для хранения дочерних узлов. В таких случаях можно использовать массив массивов или списки смежности.
